<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 作用域和预解析 -->
    let和var以及const的区别。var有着声明提升 ·即var为全局变量没有作用域也存在声明覆盖的问题，尽量少用
    <!-- 深浅拷贝 -->
    数组和对象的赋值都叫做浅拷贝（修改数据会作用于原先的数组和对象） 
    <!-- 解构赋值是浅拷贝还是深拷贝 -->
    针对一维对象和数值可以看作深拷贝，多为的就是浅拷贝。。其实也就是浅拷贝
    通过json形式进行转换是一种深拷贝的方法，并不能适用所有场景，如对于函数进行拷贝 
    封装一个深拷贝方法  
    <script>
        let arr = [1,2,3,[12,23,34]]
        function deepClone(source){
            const targetObj = source.constructor===Array ? []:{}
            for(key in source){
                if(source.hasOwnProperty()&&typeof source[key] === Object){
                    targetObj[key] = deepClone(source[key])
                } else {
                    targetObj[key] = source[key]
                }
            }
            return targetObj

        }
        // console.log(deepClone(arr))
    </script>
    <!-- 数据类型判断  -->
    typeof 运算符 返回为js的基本数据类型（数组，对象，函数都会得到object结果
    tostring 对象转换为字符方法，需要改变this 即 Object.prototype.tostri "[Object Array"
    instanceof 操作符，判断要检验的对象是否为右边的实例 obj instanceof Object 得到的结果为Boolean值，只能检验对象类型否之始终为false 
    constructor 得到该对象的构造函数 即obj.constructor = Object 
    duck type 判断一个对象是否为数组，参考类数组转换为数组

    <!-- promise和 事件轮询 -->
    promise解决事件地狱，应用在链式调用上 

    <!-- 原型和原型链以及继承 -->
    原型：事函数自带的一个属性，值是一个对象，存在的目的是为了生成实例能够共享该对象内部。
    原型链：即使用-proto-串联起来的对象结构，为对象访问机制服务
    <!--类，函数，this，继承，super ，constructor，static的概念解析-->
    this的指向，通俗来讲就是函数当前的运行环境，对于普通函数来说运行环境就是window下，所以this指向window
    对于特殊的构造函数内部的函数运行在构造函数下，this指向构造函数
    书写this.name的背后意味着什么，为社么可以这么书写呢，因为在js的底层逻辑中，函数也是一种对象，也就是说函数也是可以书写属性的，考虑到原型和原型链的内容
    函数的建立有构造函数生成现在的函数实例，而构造函数又是由对象构造函数生成的，
    故可以说函数也是一种对象即（fn.prototype指向构造函数的原型，构造函数的prototype指向对象构造函数的原型

    构造函数配合new使用, 而new关键字会将构造函数中的this指向实例化对象，所以构造函数中的this->实例化对象
    constructor构造器函数中的this运行在构造函数中故this指向为构造函数
    staic 声明 意味着该变量或是函数不被实例化或是继承，只属于自身
    super（） 
    super只能使用在构造函数，实例函数，静态函数的内部，并且有着使用上的差异
    使用构造器（函数）中着可以有super（）和super.prop两种用法前者用来调用父类中的构造函数，并将其实例化的对象赋值给子类构造构造函数的this，
    故子类要想在构造函数中使用this必须使用super（），而第二种用法则用来调用父类的原型对象中属性即方法
    调用时可分为调用实例方法和静态方法
    构造器可以使用两种方法，静态方法可以只能调用，可以使用调用实例和静态，实例方法只能调用实例方法

    <script>
     class bus{
        constructor(pramas){
            this.name=pramas

        }
        year(){
            console.log("5nian");
        }
        static old(){
            console.log('adasdads');
        }
     }
     class car extends bus{
        constructor(pramas,pramas2){
           super(pramas)
           this.year = pramas2
        }
        static try(){
          super.old()
        }
        do(){
            super.year()


        }
     }
     class tank extends bus{

     }

     const tmp = new car("tom","5")
     car.try()
     tmp.do()
     console.log(tmp);
     console.log(new tank("tank"));
        
        
    </script>

    <!-- js防抖和节流 -->

    <!-- 闭包及包装函数，高阶函数，函数柯里化 -->
    闭包是什么==函数方法内返回一个方法
    闭包的意义==延长变量的声明周期
             ==创建私有环境

    对于面向对象编程有帮助 因为面向对象编程强调数据的隐藏和封装。

    <!-- ES6 -->


    <!-- 表单处理 -->
    表单form的默认事件，以及事件冒泡和捕获处理
    event.stopPropagation()
    event.preventDefault()
    
</body>
</html>